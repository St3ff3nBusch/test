<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LUMPI Labeling: ikg::Labeling Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LUMPI Labeling
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ikg</b></li><li class="navelem"><a class="el" href="classikg_1_1_labeling.html">Labeling</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classikg_1_1_labeling-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ikg::Labeling Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classikg_1_1_labeling.html" title="The Labeling class provides functionalities for labeling and processing point cloud data.">Labeling</a> class provides functionalities for labeling and processing point cloud data.  
 <a href="classikg_1_1_labeling.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_labeling_8h_source.html">Labeling.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ikg::Labeling:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classikg_1_1_labeling.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:a161987368529ad8401d4ff9107067f17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a161987368529ad8401d4ff9107067f17">merge_track</a> (int id1, int id2)</td></tr>
<tr class="memdesc:a161987368529ad8401d4ff9107067f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge track id2 into track id1 by adding the poses of id2 which are later than the last pose or earlier than the first pose of id1.  <a href="classikg_1_1_labeling.html#a161987368529ad8401d4ff9107067f17">More...</a><br /></td></tr>
<tr class="separator:a161987368529ad8401d4ff9107067f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eb52a72c48888bb02eb851df30c0e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a24eb52a72c48888bb02eb851df30c0e3">split_track</a> (int id1, double w, SplitOption option)</td></tr>
<tr class="memdesc:a24eb52a72c48888bb02eb851df30c0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a track into two simultaneously existing objects.  <a href="classikg_1_1_labeling.html#a24eb52a72c48888bb02eb851df30c0e3">More...</a><br /></td></tr>
<tr class="separator:a24eb52a72c48888bb02eb851df30c0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474d4b5b1708a48338dcb73cf552ac2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a474d4b5b1708a48338dcb73cf552ac2f">split_track_at_time</a> (double time)</td></tr>
<tr class="memdesc:a474d4b5b1708a48338dcb73cf552ac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a track at the given time into two successively occurring tracks.  <a href="classikg_1_1_labeling.html#a474d4b5b1708a48338dcb73cf552ac2f">More...</a><br /></td></tr>
<tr class="separator:a474d4b5b1708a48338dcb73cf552ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431a02c38c377323fe31af936c9b57b6"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a431a02c38c377323fe31af936c9b57b6">generate_back_view</a> (int index, int objId)</td></tr>
<tr class="memdesc:a431a02c38c377323fe31af936c9b57b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a back view of an object by transforming 3D points to the yz-plane of the object coordinate system. Points that occlude the object are removed by a bounding box filter. All points are colored according to their timestamp.  <a href="classikg_1_1_labeling.html#a431a02c38c377323fe31af936c9b57b6">More...</a><br /></td></tr>
<tr class="separator:a431a02c38c377323fe31af936c9b57b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f89d3bee501c89664ca950405b42ec"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a71f89d3bee501c89664ca950405b42ec">generate_camera_view</a> (int index, int objId, int camId)</td></tr>
<tr class="memdesc:a71f89d3bee501c89664ca950405b42ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a camera view of an object by transforming a 3D bounding box into a camera image and cropping the image around this box. 3D points within the bounding box are also drawn into the camera image as green circles.  <a href="classikg_1_1_labeling.html#a71f89d3bee501c89664ca950405b42ec">More...</a><br /></td></tr>
<tr class="separator:a71f89d3bee501c89664ca950405b42ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12754d195294dec9a5cf2d6cdc9416d5"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a12754d195294dec9a5cf2d6cdc9416d5">generate_side_view</a> (int index, int objId)</td></tr>
<tr class="memdesc:a12754d195294dec9a5cf2d6cdc9416d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a side view of an object by transforming 3D points to the xz-plane of the object coordinate system. Points that occlude the object are removed by a bounding box filter. All points are colored according to their timestamp.  <a href="classikg_1_1_labeling.html#a12754d195294dec9a5cf2d6cdc9416d5">More...</a><br /></td></tr>
<tr class="separator:a12754d195294dec9a5cf2d6cdc9416d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b93c6d4fb52dc4e7c1a2167896b556"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a07b93c6d4fb52dc4e7c1a2167896b556">generate_single_trajectory_view</a> (int objId)</td></tr>
<tr class="memdesc:a07b93c6d4fb52dc4e7c1a2167896b556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a bird's eye view of a trajectory, drawing positions as circles and headings with arrows.  <a href="classikg_1_1_labeling.html#a07b93c6d4fb52dc4e7c1a2167896b556">More...</a><br /></td></tr>
<tr class="separator:a07b93c6d4fb52dc4e7c1a2167896b556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10758294d413df4990b40bece90ab5ed"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a10758294d413df4990b40bece90ab5ed">generate_top_view</a> (int index, int objId)</td></tr>
<tr class="memdesc:a10758294d413df4990b40bece90ab5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a top view of an object by transforming 3D points to the xy-plane of the object coordinate system. Points that occlude the object are removed by a bounding box filter. All points are colored according to their timestamp, and bounding boxes from other objects are also drawn.  <a href="classikg_1_1_labeling.html#a10758294d413df4990b40bece90ab5ed">More...</a><br /></td></tr>
<tr class="separator:a10758294d413df4990b40bece90ab5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54068f42f354a4450e028a8ea85e3e66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a54068f42f354a4450e028a8ea85e3e66">interpolate</a> (int objId, double startTime=-DBL_MAX, double endTime=DBL_MAX)</td></tr>
<tr class="memdesc:a54068f42f354a4450e028a8ea85e3e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the object's pose between the startTime and endTime.  <a href="classikg_1_1_labeling.html#a54068f42f354a4450e028a8ea85e3e66">More...</a><br /></td></tr>
<tr class="separator:a54068f42f354a4450e028a8ea85e3e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677e33d70e25dc0bdb0bcf538fe90e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a677e33d70e25dc0bdb0bcf538fe90e7f">extrapolate</a> (int objId, double toTime, bool standingFlag=false)</td></tr>
<tr class="memdesc:a677e33d70e25dc0bdb0bcf538fe90e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolate a track for the object with the given objectId up to time toTime. The speed is calculated from the last two or first two poses, or the speed is set to zero if the standingFlag is set.  <a href="classikg_1_1_labeling.html#a677e33d70e25dc0bdb0bcf538fe90e7f">More...</a><br /></td></tr>
<tr class="separator:a677e33d70e25dc0bdb0bcf538fe90e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:aff21fde6df66ff87cf2dc68299288ae0"><td class="memItemLeft" align="right" valign="top"><a id="aff21fde6df66ff87cf2dc68299288ae0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aff21fde6df66ff87cf2dc68299288ae0">update_point_cloud_view</a> ()</td></tr>
<tr class="memdesc:aff21fde6df66ff87cf2dc68299288ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal to update the point cloud view. <br /></td></tr>
<tr class="separator:aff21fde6df66ff87cf2dc68299288ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a05d3f51b6c2b0a0273f960407b2ce2f1"><td class="memItemLeft" align="right" valign="top"><a id="a05d3f51b6c2b0a0273f960407b2ce2f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a05d3f51b6c2b0a0273f960407b2ce2f1">Labeling</a> ()</td></tr>
<tr class="memdesc:a05d3f51b6c2b0a0273f960407b2ce2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="classikg_1_1_labeling.html" title="The Labeling class provides functionalities for labeling and processing point cloud data.">Labeling</a> class. <br /></td></tr>
<tr class="separator:a05d3f51b6c2b0a0273f960407b2ce2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa12a34a384b18af27f3d32f1f7cd7c"><td class="memItemLeft" align="right" valign="top"><a id="adaa12a34a384b18af27f3d32f1f7cd7c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#adaa12a34a384b18af27f3d32f1f7cd7c">~Labeling</a> ()</td></tr>
<tr class="memdesc:adaa12a34a384b18af27f3d32f1f7cd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the <a class="el" href="classikg_1_1_labeling.html" title="The Labeling class provides functionalities for labeling and processing point cloud data.">Labeling</a> class. <br /></td></tr>
<tr class="separator:adaa12a34a384b18af27f3d32f1f7cd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c1f078a0ae5e5c9f995e3eb4468165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af4c1f078a0ae5e5c9f995e3eb4468165">add_obj</a> (cv::Point3d position)</td></tr>
<tr class="memdesc:af4c1f078a0ae5e5c9f995e3eb4468165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new 1m x 1m x 1m bounding box at the specified position.  <a href="classikg_1_1_labeling.html#af4c1f078a0ae5e5c9f995e3eb4468165">More...</a><br /></td></tr>
<tr class="separator:af4c1f078a0ae5e5c9f995e3eb4468165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f22ce87af6f799efea1ec116b99e1c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a6f22ce87af6f799efea1ec116b99e1c9">aggregate_points</a> (const int &amp;tId, const int &amp;sIndex, const int &amp;eIndex, const double &amp;<a class="el" href="classikg_1_1_labeling.html#a11dfdf2ed4f641a923289e46a176fce1">resolution</a>, const int &amp;stepSize)</td></tr>
<tr class="memdesc:a6f22ce87af6f799efea1ec116b99e1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate all points within the object bounding box for a single track starting at startIndex up to endIndex by incrementing point cloud index with stepSize.  <a href="classikg_1_1_labeling.html#a6f22ce87af6f799efea1ec116b99e1c9">More...</a><br /></td></tr>
<tr class="separator:a6f22ce87af6f799efea1ec116b99e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfa8fb74ae8343f533fe3fbe97dc7bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a0bfa8fb74ae8343f533fe3fbe97dc7bc">definalized</a> (int objId)</td></tr>
<tr class="memdesc:a0bfa8fb74ae8343f533fe3fbe97dc7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the finalize flag at each pose for the specified object.  <a href="classikg_1_1_labeling.html#a0bfa8fb74ae8343f533fe3fbe97dc7bc">More...</a><br /></td></tr>
<tr class="separator:a0bfa8fb74ae8343f533fe3fbe97dc7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf75e9dca038a8521b6fd776b9c3ae35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#acf75e9dca038a8521b6fd776b9c3ae35">erase_obj</a> (int objId)</td></tr>
<tr class="memdesc:acf75e9dca038a8521b6fd776b9c3ae35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the object with the specified ID.  <a href="classikg_1_1_labeling.html#acf75e9dca038a8521b6fd776b9c3ae35">More...</a><br /></td></tr>
<tr class="separator:acf75e9dca038a8521b6fd776b9c3ae35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dd4b0d551e4bf1edda0be377d7a276"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af5dd4b0d551e4bf1edda0be377d7a276">erase_pose</a> (int objId, double startTime, double endTime=-1)</td></tr>
<tr class="memdesc:af5dd4b0d551e4bf1edda0be377d7a276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase poses of an object between startTime and endTime. If startTime is smaller than endTime, only the pose at startTime is deleted.  <a href="classikg_1_1_labeling.html#af5dd4b0d551e4bf1edda0be377d7a276">More...</a><br /></td></tr>
<tr class="separator:af5dd4b0d551e4bf1edda0be377d7a276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4cff6a299b72ac84c88e0f5370a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a1fc4cff6a299b72ac84c88e0f5370a4a">finalized</a> (int objId)</td></tr>
<tr class="memdesc:a1fc4cff6a299b72ac84c88e0f5370a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the finalize flag at each pose for the specified object.  <a href="classikg_1_1_labeling.html#a1fc4cff6a299b72ac84c88e0f5370a4a">More...</a><br /></td></tr>
<tr class="separator:a1fc4cff6a299b72ac84c88e0f5370a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d75383c20cb6d7f7444f267653829d"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a95d75383c20cb6d7f7444f267653829d">generate_camera_global_view</a> (double time, int camId)</td></tr>
<tr class="memdesc:a95d75383c20cb6d7f7444f267653829d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render objects and their masks at a point cloud index to the corresponding camera frame. Masks are generated for each object if its model exists by calculating its convex hull.  <a href="classikg_1_1_labeling.html#a95d75383c20cb6d7f7444f267653829d">More...</a><br /></td></tr>
<tr class="separator:a95d75383c20cb6d7f7444f267653829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44e534d2cc112c783d3236bb1f0a49b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af44e534d2cc112c783d3236bb1f0a49b">get_active_bb_at_index</a> (int pointCloudIndex, <a class="el" href="classikg_1_1_pose.html">Pose</a> *&amp;pose)</td></tr>
<tr class="memdesc:af44e534d2cc112c783d3236bb1f0a49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pose of the active object at the specified point cloud index.  <a href="classikg_1_1_labeling.html#af44e534d2cc112c783d3236bb1f0a49b">More...</a><br /></td></tr>
<tr class="separator:af44e534d2cc112c783d3236bb1f0a49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acd8a4ccfb0a8e7ff5403cfc8092186"><td class="memItemLeft" align="right" valign="top">pcl::PointCloud&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a4acd8a4ccfb0a8e7ff5403cfc8092186">get_cloud</a> (int index, bool recolor=false)</td></tr>
<tr class="memdesc:a4acd8a4ccfb0a8e7ff5403cfc8092186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point cloud at the specified index. If not yet loaded, load the point cloud from disk.  <a href="classikg_1_1_labeling.html#a4acd8a4ccfb0a8e7ff5403cfc8092186">More...</a><br /></td></tr>
<tr class="separator:a4acd8a4ccfb0a8e7ff5403cfc8092186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a50cfcee3a094c12c0347f469406eb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a8a50cfcee3a094c12c0347f469406eb1">get_intersecting_obj</a> (int objId, double time)</td></tr>
<tr class="memdesc:a8a50cfcee3a094c12c0347f469406eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all IDs of objects whose bounding boxes intersect with the specified object ID at a given time.  <a href="classikg_1_1_labeling.html#a8a50cfcee3a094c12c0347f469406eb1">More...</a><br /></td></tr>
<tr class="separator:a8a50cfcee3a094c12c0347f469406eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206a7accc991955874fb53805e55a30"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a3206a7accc991955874fb53805e55a30">get_obj_at</a> (cv::Point2d p, double startTime, double endTime, bool activeObjOnly) const</td></tr>
<tr class="memdesc:a3206a7accc991955874fb53805e55a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the nearest object pose to a given 2D point. The selection can be constrained by time and/or the active object ID.  <a href="classikg_1_1_labeling.html#a3206a7accc991955874fb53805e55a30">More...</a><br /></td></tr>
<tr class="separator:a3206a7accc991955874fb53805e55a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20008513d81c0d3bac52eae32429f4ca"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a20008513d81c0d3bac52eae32429f4ca">get_obj_at</a> (cv::Point3d p, int index) const</td></tr>
<tr class="memdesc:a20008513d81c0d3bac52eae32429f4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the object from the objects at the specified point cloud index that is closest to the given 3D point.  <a href="classikg_1_1_labeling.html#a20008513d81c0d3bac52eae32429f4ca">More...</a><br /></td></tr>
<tr class="separator:a20008513d81c0d3bac52eae32429f4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ece5fb59fb9f64c8ec549966a91c92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a10ece5fb59fb9f64c8ec549966a91c92">get_points_at_obj</a> (int index, int objId)</td></tr>
<tr class="memdesc:a10ece5fb59fb9f64c8ec549966a91c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all points within an object's bounding box. Returns an empty vector if the object doesn't exist at the specified point cloud index.  <a href="classikg_1_1_labeling.html#a10ece5fb59fb9f64c8ec549966a91c92">More...</a><br /></td></tr>
<tr class="separator:a10ece5fb59fb9f64c8ec549966a91c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd157f9be45c7daa1a6ff1ad183d830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a6fd157f9be45c7daa1a6ff1ad183d830">init</a> (std::string <a class="el" href="classikg_1_1_labeling.html#a9649fd3991ba3516fdccae8716d424a4">dataPath</a>, std::string <a class="el" href="classikg_1_1_labeling.html#a70950caa7b3797488a299b52515d874b">trajectoryPath</a>, int expId)</td></tr>
<tr class="memdesc:a6fd157f9be45c7daa1a6ff1ad183d830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the labeling session by loading the sensor calibration data from the meta file, setting the data path, and loading objects from a file.  <a href="classikg_1_1_labeling.html#a6fd157f9be45c7daa1a6ff1ad183d830">More...</a><br /></td></tr>
<tr class="separator:a6fd157f9be45c7daa1a6ff1ad183d830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7f0045a75a7218310fc547b8a10db1"><td class="memItemLeft" align="right" valign="top"><a id="aca7f0045a75a7218310fc547b8a10db1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aca7f0045a75a7218310fc547b8a10db1">interpolate_between_key_frames</a> ()</td></tr>
<tr class="memdesc:aca7f0045a75a7218310fc547b8a10db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate all poses for the actual object between key frames (defined by step size). <br /></td></tr>
<tr class="separator:aca7f0045a75a7218310fc547b8a10db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ed9402464c03bac8d97b9dd156b41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ac9ed9402464c03bac8d97b9dd156b41c">interpolate_single_between_key_frames</a> (int objId, double time)</td></tr>
<tr class="memdesc:ac9ed9402464c03bac8d97b9dd156b41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates between key frames (defined by actual step size) around a time stamp.  <a href="classikg_1_1_labeling.html#ac9ed9402464c03bac8d97b9dd156b41c">More...</a><br /></td></tr>
<tr class="separator:ac9ed9402464c03bac8d97b9dd156b41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddabc79085ef0eff4ba8615f9b79279"><td class="memItemLeft" align="right" valign="top"><a id="abddabc79085ef0eff4ba8615f9b79279"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#abddabc79085ef0eff4ba8615f9b79279">load_back_ground</a> ()</td></tr>
<tr class="memdesc:abddabc79085ef0eff4ba8615f9b79279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the background into member variables. <br /></td></tr>
<tr class="separator:abddabc79085ef0eff4ba8615f9b79279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f6ed312c0f9a542799bc2306bce5eb"><td class="memItemLeft" align="right" valign="top"><a id="a15f6ed312c0f9a542799bc2306bce5eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a15f6ed312c0f9a542799bc2306bce5eb">load_camera_parameters_and_videos</a> ()</td></tr>
<tr class="memdesc:a15f6ed312c0f9a542799bc2306bce5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the camera parameters and the video streams. <br /></td></tr>
<tr class="separator:a15f6ed312c0f9a542799bc2306bce5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67767dc75f36d79a56b2df9441eda7ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a67767dc75f36d79a56b2df9441eda7ea">load_point_cloud_sliding_window</a> ()</td></tr>
<tr class="memdesc:a67767dc75f36d79a56b2df9441eda7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load point clouds from i-slidingWindow*actualStepSize to i+slidingWindow*actualStepSize.  <a href="classikg_1_1_labeling.html#a67767dc75f36d79a56b2df9441eda7ea">More...</a><br /></td></tr>
<tr class="separator:a67767dc75f36d79a56b2df9441eda7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba0451612d9a0552f36b13d225e65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a55ba0451612d9a0552f36b13d225e65b">load_trajectories</a> (std::string path)</td></tr>
<tr class="memdesc:a55ba0451612d9a0552f36b13d225e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load object tracks.  <a href="classikg_1_1_labeling.html#a55ba0451612d9a0552f36b13d225e65b">More...</a><br /></td></tr>
<tr class="separator:a55ba0451612d9a0552f36b13d225e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5568754bbe17e6ec5517d0038c287838"><td class="memItemLeft" align="right" valign="top"><a id="a5568754bbe17e6ec5517d0038c287838"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a5568754bbe17e6ec5517d0038c287838">reset_pc_views</a> ()</td></tr>
<tr class="memdesc:a5568754bbe17e6ec5517d0038c287838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all point cloud views by removing all point clouds and setting the background to white color. <br /></td></tr>
<tr class="separator:a5568754bbe17e6ec5517d0038c287838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d9e59049668ad0b60c228245b8804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af34d9e59049668ad0b60c228245b8804">set_point_cloud</a> (int index, int view)</td></tr>
<tr class="memdesc:af34d9e59049668ad0b60c228245b8804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the point cloud in the map at view to the point cloud with the specified index.  <a href="classikg_1_1_labeling.html#af34d9e59049668ad0b60c228245b8804">More...</a><br /></td></tr>
<tr class="separator:af34d9e59049668ad0b60c228245b8804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b4a57183f66120cc790ec99c42f644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a03b4a57183f66120cc790ec99c42f644">set_standing_pose_by_key_frames</a> (int objId, double time)</td></tr>
<tr class="memdesc:a03b4a57183f66120cc790ec99c42f644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all poses between the previous and next key frame to the pose of the previous key frame.  <a href="classikg_1_1_labeling.html#a03b4a57183f66120cc790ec99c42f644">More...</a><br /></td></tr>
<tr class="separator:a03b4a57183f66120cc790ec99c42f644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf486823ce1b046b9cb28a3115cf065"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aacf486823ce1b046b9cb28a3115cf065">split_point_segment</a> (std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;points, double threshold)</td></tr>
<tr class="memdesc:aacf486823ce1b046b9cb28a3115cf065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the biggest subset of points with homogeneous timestamps with a time difference smaller than the threshold.  <a href="classikg_1_1_labeling.html#aacf486823ce1b046b9cb28a3115cf065">More...</a><br /></td></tr>
<tr class="separator:aacf486823ce1b046b9cb28a3115cf065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09723c9f6dc998ab8195bee6ce458201"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a09723c9f6dc998ab8195bee6ce458201">generate_global_point_cloud_view</a> ()</td></tr>
<tr class="memdesc:a09723c9f6dc998ab8195bee6ce458201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the global point cloud view: visualizing the actual point cloud and all bounding boxes at this point cloud index.  <a href="classikg_1_1_labeling.html#a09723c9f6dc998ab8195bee6ce458201">More...</a><br /></td></tr>
<tr class="separator:a09723c9f6dc998ab8195bee6ce458201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cf3c0df90e00c4f1844d2bbccc208c"><td class="memItemLeft" align="right" valign="top"><a id="a31cf3c0df90e00c4f1844d2bbccc208c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a31cf3c0df90e00c4f1844d2bbccc208c">generate_model_view</a> ()</td></tr>
<tr class="memdesc:a31cf3c0df90e00c4f1844d2bbccc208c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render the active object to the model view, if the aggregated point cloud grid exists. <br /></td></tr>
<tr class="separator:a31cf3c0df90e00c4f1844d2bbccc208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0c5067b609f1df051dd5253527ce60"><td class="memItemLeft" align="right" valign="top"><a id="a5b0c5067b609f1df051dd5253527ce60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a5b0c5067b609f1df051dd5253527ce60">update_obj_ptr</a> ()</td></tr>
<tr class="memdesc:a5b0c5067b609f1df051dd5253527ce60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all pose pointers. <br /></td></tr>
<tr class="separator:a5b0c5067b609f1df051dd5253527ce60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2868767de2c920d229990249bfe9ab32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a2868767de2c920d229990249bfe9ab32">update_pc_bb</a> (int index)</td></tr>
<tr class="memdesc:a2868767de2c920d229990249bfe9ab32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render all bounding boxes at the specified point cloud index.  <a href="classikg_1_1_labeling.html#a2868767de2c920d229990249bfe9ab32">More...</a><br /></td></tr>
<tr class="separator:a2868767de2c920d229990249bfe9ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b333ee2332c6083b6dae6b9debe23c4"><td class="memItemLeft" align="right" valign="top"><a id="a9b333ee2332c6083b6dae6b9debe23c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a9b333ee2332c6083b6dae6b9debe23c4">update_pc_index_list</a> ()</td></tr>
<tr class="memdesc:a9b333ee2332c6083b6dae6b9debe23c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update point cloud indices to match the file list. <br /></td></tr>
<tr class="separator:a9b333ee2332c6083b6dae6b9debe23c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef0fd02bf2b4f81644d76100872b7f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a3ef0fd02bf2b4f81644d76100872b7f9">set_back_ground_color_local_view</a> (<a class="el" href="classikg_1_1_pose.html">Pose</a> *po, cv::Mat &amp;tv)</td></tr>
<tr class="memdesc:a3ef0fd02bf2b4f81644d76100872b7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the background color of bird's eye, side, and back view, depending on the pose state. Default color is white, finalized color is blue, interpolated color is gray, and standing color is black.  <a href="classikg_1_1_labeling.html#a3ef0fd02bf2b4f81644d76100872b7f9">More...</a><br /></td></tr>
<tr class="separator:a3ef0fd02bf2b4f81644d76100872b7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1758ad29a739c7773f67c2a8af951c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aed1758ad29a739c7773f67c2a8af951c">creat_time_heat_map</a> (const std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;pointCloud, cv::Mat &amp;heat_map)</td></tr>
<tr class="memdesc:aed1758ad29a739c7773f67c2a8af951c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a heat map for the times of the given points.  <a href="classikg_1_1_labeling.html#aed1758ad29a739c7773f67c2a8af951c">More...</a><br /></td></tr>
<tr class="separator:aed1758ad29a739c7773f67c2a8af951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed8752e72f95f0d5a3b452f1fca54c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a7eed8752e72f95f0d5a3b452f1fca54c">get_time_of_largest_point_segment</a> (std::vector&lt; double &gt; &amp;time, double th)</td></tr>
<tr class="memdesc:a7eed8752e72f95f0d5a3b452f1fca54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mean timestamp of the largest point segment. Segment by sorting the times and splitting segments with a time difference above the threshold.  <a href="classikg_1_1_labeling.html#a7eed8752e72f95f0d5a3b452f1fca54c">More...</a><br /></td></tr>
<tr class="separator:a7eed8752e72f95f0d5a3b452f1fca54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad658e6b9040b57d65452f40d169c1ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ad658e6b9040b57d65452f40d169c1ca5">grid_to_point_cloud</a> (const std::unordered_map&lt; int, std::unordered_map&lt; int, std::unordered_map&lt; int, int &gt; &gt; &gt; &amp;grid, const double &amp;<a class="el" href="classikg_1_1_labeling.html#a11dfdf2ed4f641a923289e46a176fce1">resolution</a>, std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:ad658e6b9040b57d65452f40d169c1ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a 3D grid [x,y,z,count] to a point cloud.  <a href="classikg_1_1_labeling.html#ad658e6b9040b57d65452f40d169c1ca5">More...</a><br /></td></tr>
<tr class="separator:ad658e6b9040b57d65452f40d169c1ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0022eb4543648769ff4425de22a5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a3b0022eb4543648769ff4425de22a5e2">point_vector_to_xyz_cloud</a> (const std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;points, pcl::PointCloud&lt; pcl::PointXYZ &gt; &amp;cloudXYZ)</td></tr>
<tr class="memdesc:a3b0022eb4543648769ff4425de22a5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point vector to a xyz cloud.  <a href="classikg_1_1_labeling.html#a3b0022eb4543648769ff4425de22a5e2">More...</a><br /></td></tr>
<tr class="separator:a3b0022eb4543648769ff4425de22a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d42b10cd07532f0e4bd791a928b64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ac3d42b10cd07532f0e4bd791a928b64d">point_cloud_to_XYZRGBA</a> (const pcl::PointCloud&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;points, pcl::PointCloud&lt; pcl::PointXYZRGBA &gt; &amp;tmpC)</td></tr>
<tr class="memdesc:ac3d42b10cd07532f0e4bd791a928b64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an <a class="el" href="struct_i_k_g_b.html" title="Struct representing a point with various attributes.">IKGB</a> point cloud to a pcl::XYZRGBA cloud.  <a href="classikg_1_1_labeling.html#ac3d42b10cd07532f0e4bd791a928b64d">More...</a><br /></td></tr>
<tr class="separator:ac3d42b10cd07532f0e4bd791a928b64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2222555fc778ef44f60c88da2b592d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aff2222555fc778ef44f60c88da2b592d">get_convex_hull_indices</a> (const std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:aff2222555fc778ef44f60c88da2b592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of all points at the convex hull for the given <a class="el" href="struct_i_k_g_b.html" title="Struct representing a point with various attributes.">IKGB</a> point vector.  <a href="classikg_1_1_labeling.html#aff2222555fc778ef44f60c88da2b592d">More...</a><br /></td></tr>
<tr class="separator:aff2222555fc778ef44f60c88da2b592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a040c7d4ff3a41d38a4e3468adee6552e"><td class="memItemLeft" align="right" valign="top"><a id="a040c7d4ff3a41d38a4e3468adee6552e"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a040c7d4ff3a41d38a4e3468adee6552e">classNames</a></td></tr>
<tr class="memdesc:a040c7d4ff3a41d38a4e3468adee6552e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all class name options. <br /></td></tr>
<tr class="separator:a040c7d4ff3a41d38a4e3468adee6552e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e86624c16e6d9232bec2ab2ca4fba3"><td class="memItemLeft" align="right" valign="top"><a id="a39e86624c16e6d9232bec2ab2ca4fba3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a39e86624c16e6d9232bec2ab2ca4fba3">measurementSubString</a></td></tr>
<tr class="memdesc:a39e86624c16e6d9232bec2ab2ca4fba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substring used for measurement identification. <br /></td></tr>
<tr class="separator:a39e86624c16e6d9232bec2ab2ca4fba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ac9e418664e42ecbdb42ffc9a10dac"><td class="memItemLeft" align="right" valign="top"><a id="a91ac9e418664e42ecbdb42ffc9a10dac"></a>
std::unordered_map&lt; int, std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a91ac9e418664e42ecbdb42ffc9a10dac">models</a></td></tr>
<tr class="memdesc:a91ac9e418664e42ecbdb42ffc9a10dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the convex hull of aggregated point clouds. <br /></td></tr>
<tr class="separator:a91ac9e418664e42ecbdb42ffc9a10dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25fda32462059d9547702befcd38428"><td class="memItemLeft" align="right" valign="top"><a id="af25fda32462059d9547702befcd38428"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af25fda32462059d9547702befcd38428">columViewSize</a></td></tr>
<tr class="memdesc:af25fda32462059d9547702befcd38428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of GUI elements (columns). <br /></td></tr>
<tr class="separator:af25fda32462059d9547702befcd38428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657033cb57434a38b7cc6e09095c8260"><td class="memItemLeft" align="right" valign="top"><a id="a657033cb57434a38b7cc6e09095c8260"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a657033cb57434a38b7cc6e09095c8260">rowViewSize</a></td></tr>
<tr class="memdesc:a657033cb57434a38b7cc6e09095c8260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of GUI elements (rows). <br /></td></tr>
<tr class="separator:a657033cb57434a38b7cc6e09095c8260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b3945ba8b2241a2f51a1a79e9fc053"><td class="memItemLeft" align="right" valign="top"><a id="ac8b3945ba8b2241a2f51a1a79e9fc053"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ac8b3945ba8b2241a2f51a1a79e9fc053">measurementId</a></td></tr>
<tr class="memdesc:ac8b3945ba8b2241a2f51a1a79e9fc053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the measurement ID for data path generation and metadata loading. <br /></td></tr>
<tr class="separator:ac8b3945ba8b2241a2f51a1a79e9fc053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13d5fa87c25bea9264b6f9d9e841ba8"><td class="memItemLeft" align="right" valign="top"><a id="ae13d5fa87c25bea9264b6f9d9e841ba8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ae13d5fa87c25bea9264b6f9d9e841ba8">activObjId</a></td></tr>
<tr class="memdesc:ae13d5fa87c25bea9264b6f9d9e841ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the active object ID. <br /></td></tr>
<tr class="separator:ae13d5fa87c25bea9264b6f9d9e841ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f2efba79b8f33c0ce660f2565ed20"><td class="memItemLeft" align="right" valign="top"><a id="acc4f2efba79b8f33c0ce660f2565ed20"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#acc4f2efba79b8f33c0ce660f2565ed20">actualIndex</a></td></tr>
<tr class="memdesc:acc4f2efba79b8f33c0ce660f2565ed20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the actual point cloud index. <br /></td></tr>
<tr class="separator:acc4f2efba79b8f33c0ce660f2565ed20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c83c992b2c0df349c91acb960d444e"><td class="memItemLeft" align="right" valign="top"><a id="a05c83c992b2c0df349c91acb960d444e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a05c83c992b2c0df349c91acb960d444e">globalCameraId</a></td></tr>
<tr class="memdesc:a05c83c992b2c0df349c91acb960d444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the global camera ID. <br /></td></tr>
<tr class="separator:a05c83c992b2c0df349c91acb960d444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f4a4c9ce2d780617cc58310955d661"><td class="memItemLeft" align="right" valign="top"><a id="a02f4a4c9ce2d780617cc58310955d661"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a02f4a4c9ce2d780617cc58310955d661">pointCloudPath</a></td></tr>
<tr class="memdesc:a02f4a4c9ce2d780617cc58310955d661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the point cloud data. <br /></td></tr>
<tr class="separator:a02f4a4c9ce2d780617cc58310955d661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e1a563ac460bc7a9189ca4d0d42298"><td class="memItemLeft" align="right" valign="top"><a id="a17e1a563ac460bc7a9189ca4d0d42298"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a17e1a563ac460bc7a9189ca4d0d42298">cameraPath</a></td></tr>
<tr class="memdesc:a17e1a563ac460bc7a9189ca4d0d42298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the camera data. <br /></td></tr>
<tr class="separator:a17e1a563ac460bc7a9189ca4d0d42298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcb9341546ac9e701f2627a7c2efc7b"><td class="memItemLeft" align="right" valign="top"><a id="a4bcb9341546ac9e701f2627a7c2efc7b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a4bcb9341546ac9e701f2627a7c2efc7b">metaPath</a></td></tr>
<tr class="memdesc:a4bcb9341546ac9e701f2627a7c2efc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the metadata. <br /></td></tr>
<tr class="separator:a4bcb9341546ac9e701f2627a7c2efc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97b932b2e00c1b251aa596d7f083c20"><td class="memItemLeft" align="right" valign="top"><a id="ab97b932b2e00c1b251aa596d7f083c20"></a>
std::map&lt; int, <a class="el" href="classikg_1_1_sensor.html">Sensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ab97b932b2e00c1b251aa596d7f083c20">cams</a></td></tr>
<tr class="memdesc:ab97b932b2e00c1b251aa596d7f083c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores camera parameters and video paths. <br /></td></tr>
<tr class="separator:ab97b932b2e00c1b251aa596d7f083c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c85b1f9f347765a78a1824f13725f60"><td class="memItemLeft" align="right" valign="top"><a id="a6c85b1f9f347765a78a1824f13725f60"></a>
std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a6c85b1f9f347765a78a1824f13725f60">selectedCam</a></td></tr>
<tr class="memdesc:a6c85b1f9f347765a78a1824f13725f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the selected camera ID for each operational row. <br /></td></tr>
<tr class="separator:a6c85b1f9f347765a78a1824f13725f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76229099add4bda5160ae33aafaa7225"><td class="memItemLeft" align="right" valign="top"><a id="a76229099add4bda5160ae33aafaa7225"></a>
std::map&lt; int, pcl::PointCloud&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a76229099add4bda5160ae33aafaa7225">clouds</a></td></tr>
<tr class="memdesc:a76229099add4bda5160ae33aafaa7225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the visible point clouds. <br /></td></tr>
<tr class="separator:a76229099add4bda5160ae33aafaa7225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c998812a9c7fe6f626809adfcd0fb9c"><td class="memItemLeft" align="right" valign="top"><a id="a9c998812a9c7fe6f626809adfcd0fb9c"></a>
std::pair&lt; int, pcl::PointCloud&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a9c998812a9c7fe6f626809adfcd0fb9c">tmpCloud</a></td></tr>
<tr class="memdesc:a9c998812a9c7fe6f626809adfcd0fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a temporal cloud with its index for efficient access. <br /></td></tr>
<tr class="separator:a9c998812a9c7fe6f626809adfcd0fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4635a50d76cf6095c2463be9ee04402"><td class="memItemLeft" align="right" valign="top"><a id="ac4635a50d76cf6095c2463be9ee04402"></a>
std::unordered_map&lt; int, cv::VideoCapture &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ac4635a50d76cf6095c2463be9ee04402">caps</a></td></tr>
<tr class="memdesc:ac4635a50d76cf6095c2463be9ee04402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the videos. <br /></td></tr>
<tr class="separator:ac4635a50d76cf6095c2463be9ee04402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7588297d14d7f66b50945fb25ffe701"><td class="memItemLeft" align="right" valign="top"><a id="ae7588297d14d7f66b50945fb25ffe701"></a>
std::unordered_map&lt; int, std::map&lt; double, cv::Mat &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ae7588297d14d7f66b50945fb25ffe701">camViews</a></td></tr>
<tr class="memdesc:ae7588297d14d7f66b50945fb25ffe701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the single camera views per operation row. <br /></td></tr>
<tr class="separator:ae7588297d14d7f66b50945fb25ffe701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0708f5ebfe7cef0560c3863c15b94333"><td class="memItemLeft" align="right" valign="top"><a id="a0708f5ebfe7cef0560c3863c15b94333"></a>
std::map&lt; int, pcl::visualization::PCLVisualizer::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a0708f5ebfe7cef0560c3863c15b94333">pcViews</a></td></tr>
<tr class="memdesc:a0708f5ebfe7cef0560c3863c15b94333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores single point cloud views per operational row. <br /></td></tr>
<tr class="separator:a0708f5ebfe7cef0560c3863c15b94333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b7f49bacef66adc5d27868165be309"><td class="memItemLeft" align="right" valign="top"><a id="a53b7f49bacef66adc5d27868165be309"></a>
pcl::visualization::PCLVisualizer::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a53b7f49bacef66adc5d27868165be309">globPcView</a></td></tr>
<tr class="memdesc:a53b7f49bacef66adc5d27868165be309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the global point cloud at the actual index. <br /></td></tr>
<tr class="separator:a53b7f49bacef66adc5d27868165be309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d0317197ed591a6f375d8b3c47c3bd"><td class="memItemLeft" align="right" valign="top"><a id="ad6d0317197ed591a6f375d8b3c47c3bd"></a>
pcl::visualization::PCLVisualizer::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ad6d0317197ed591a6f375d8b3c47c3bd">modelPcView</a></td></tr>
<tr class="memdesc:ad6d0317197ed591a6f375d8b3c47c3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the point of the convex hull for the aggregated points of a track. <br /></td></tr>
<tr class="separator:ad6d0317197ed591a6f375d8b3c47c3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9649fd3991ba3516fdccae8716d424a4"><td class="memItemLeft" align="right" valign="top"><a id="a9649fd3991ba3516fdccae8716d424a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a9649fd3991ba3516fdccae8716d424a4">dataPath</a></td></tr>
<tr class="memdesc:a9649fd3991ba3516fdccae8716d424a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the data. <br /></td></tr>
<tr class="separator:a9649fd3991ba3516fdccae8716d424a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70950caa7b3797488a299b52515d874b"><td class="memItemLeft" align="right" valign="top"><a id="a70950caa7b3797488a299b52515d874b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a70950caa7b3797488a299b52515d874b">trajectoryPath</a></td></tr>
<tr class="memdesc:a70950caa7b3797488a299b52515d874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the trajectory data. <br /></td></tr>
<tr class="separator:a70950caa7b3797488a299b52515d874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0cb683b39f20074acd793615b0c931"><td class="memItemLeft" align="right" valign="top"><a id="ada0cb683b39f20074acd793615b0c931"></a>
std::map&lt; int, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ada0cb683b39f20074acd793615b0c931">topView</a></td></tr>
<tr class="memdesc:ada0cb683b39f20074acd793615b0c931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the 2D views per operation row (top view). <br /></td></tr>
<tr class="separator:ada0cb683b39f20074acd793615b0c931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de2858e447f7db47f8e59a699d756f"><td class="memItemLeft" align="right" valign="top"><a id="a31de2858e447f7db47f8e59a699d756f"></a>
std::map&lt; int, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a31de2858e447f7db47f8e59a699d756f">sideView</a></td></tr>
<tr class="memdesc:a31de2858e447f7db47f8e59a699d756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the 2D views per operation row (side view). <br /></td></tr>
<tr class="separator:a31de2858e447f7db47f8e59a699d756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914945e3aacffd124bb5ef4a28faf1d5"><td class="memItemLeft" align="right" valign="top"><a id="a914945e3aacffd124bb5ef4a28faf1d5"></a>
std::map&lt; int, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a914945e3aacffd124bb5ef4a28faf1d5">backView</a></td></tr>
<tr class="memdesc:a914945e3aacffd124bb5ef4a28faf1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the 2D views per operation row (back view). <br /></td></tr>
<tr class="separator:a914945e3aacffd124bb5ef4a28faf1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1326113bc14c05813be739bfd86502ac"><td class="memItemLeft" align="right" valign="top"><a id="a1326113bc14c05813be739bfd86502ac"></a>
std::map&lt; int, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a1326113bc14c05813be739bfd86502ac">camView</a></td></tr>
<tr class="memdesc:a1326113bc14c05813be739bfd86502ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the 2D views per operation row (camera view). <br /></td></tr>
<tr class="separator:a1326113bc14c05813be739bfd86502ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735749c20dfae4304d4587432ae85b36"><td class="memItemLeft" align="right" valign="top"><a id="a735749c20dfae4304d4587432ae85b36"></a>
std::map&lt; int, std::unordered_map&lt; int, <a class="el" href="classikg_1_1_pose.html">Pose</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a735749c20dfae4304d4587432ae85b36">posePerTime</a></td></tr>
<tr class="memdesc:a735749c20dfae4304d4587432ae85b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps poses to point cloud indices. <br /></td></tr>
<tr class="separator:a735749c20dfae4304d4587432ae85b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b5de44bc14eb7e525fa755b6c36c8"><td class="memItemLeft" align="right" valign="top"><a id="a227b5de44bc14eb7e525fa755b6c36c8"></a>
std::unordered_map&lt; int, std::map&lt; int, <a class="el" href="classikg_1_1_pose.html">Pose</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a227b5de44bc14eb7e525fa755b6c36c8">posePerObj</a></td></tr>
<tr class="memdesc:a227b5de44bc14eb7e525fa755b6c36c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps poses to object IDs. <br /></td></tr>
<tr class="separator:a227b5de44bc14eb7e525fa755b6c36c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f707116a05560d4f5fbe52e361a8503"><td class="memItemLeft" align="right" valign="top"><a id="a6f707116a05560d4f5fbe52e361a8503"></a>
std::map&lt; int, <a class="el" href="classikg_1_1_trajectory.html">Trajectory</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a6f707116a05560d4f5fbe52e361a8503">id2traj</a></td></tr>
<tr class="memdesc:a6f707116a05560d4f5fbe52e361a8503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps object IDs to trajectories. <br /></td></tr>
<tr class="separator:a6f707116a05560d4f5fbe52e361a8503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd895a403fb9365e4859982a7051a37"><td class="memItemLeft" align="right" valign="top"><a id="a4dd895a403fb9365e4859982a7051a37"></a>
std::unordered_map&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a4dd895a403fb9365e4859982a7051a37">inter</a></td></tr>
<tr class="memdesc:a4dd895a403fb9365e4859982a7051a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores interpolation flags. <br /></td></tr>
<tr class="separator:a4dd895a403fb9365e4859982a7051a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf26b6199c9dac3a36705706a374c634"><td class="memItemLeft" align="right" valign="top"><a id="acf26b6199c9dac3a36705706a374c634"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#acf26b6199c9dac3a36705706a374c634">stepSizes</a></td></tr>
<tr class="memdesc:acf26b6199c9dac3a36705706a374c634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all step size options. <br /></td></tr>
<tr class="separator:acf26b6199c9dac3a36705706a374c634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891f34ba1c87c2233527ac590198b39"><td class="memItemLeft" align="right" valign="top"><a id="ac891f34ba1c87c2233527ac590198b39"></a>
cv::Point2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ac891f34ba1c87c2233527ac590198b39">globalTrajectoryCenter</a></td></tr>
<tr class="memdesc:ac891f34ba1c87c2233527ac590198b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the 2D center of the trajectory view for choosing trajectories. <br /></td></tr>
<tr class="separator:ac891f34ba1c87c2233527ac590198b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb3051ede06c2ae396fc1254dc277af"><td class="memItemLeft" align="right" valign="top"><a id="aeeb3051ede06c2ae396fc1254dc277af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aeeb3051ede06c2ae396fc1254dc277af">actualStepSize</a></td></tr>
<tr class="memdesc:aeeb3051ede06c2ae396fc1254dc277af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the chosen step size. <br /></td></tr>
<tr class="separator:aeeb3051ede06c2ae396fc1254dc277af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09caa20520bd44b65982f41364aa5491"><td class="memItemLeft" align="right" valign="top"><a id="a09caa20520bd44b65982f41364aa5491"></a>
std::vector&lt; <a class="el" href="classikg_1_1_trajectory.html">Trajectory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a09caa20520bd44b65982f41364aa5491">pcTrajectories</a></td></tr>
<tr class="memdesc:a09caa20520bd44b65982f41364aa5491"><td class="mdescLeft">&#160;</td><td class="mdescRight">The track database all maps refer to these tracks. <br /></td></tr>
<tr class="separator:a09caa20520bd44b65982f41364aa5491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc9ac073109aa14d9a54150260ffa61"><td class="memItemLeft" align="right" valign="top"><a id="aedc9ac073109aa14d9a54150260ffa61"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aedc9ac073109aa14d9a54150260ffa61">pointCloudIndices</a></td></tr>
<tr class="memdesc:aedc9ac073109aa14d9a54150260ffa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all possible point cloud indices. <br /></td></tr>
<tr class="separator:aedc9ac073109aa14d9a54150260ffa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe716f5094c1737c7cceada4c974d26c"><td class="memItemLeft" align="right" valign="top"><a id="afe716f5094c1737c7cceada4c974d26c"></a>
std::unordered_map&lt; int, cv::Vec3b &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#afe716f5094c1737c7cceada4c974d26c">colors</a></td></tr>
<tr class="memdesc:afe716f5094c1737c7cceada4c974d26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores colors for different objects. <br /></td></tr>
<tr class="separator:afe716f5094c1737c7cceada4c974d26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ecfe26e3713bcda51fb12259041676"><td class="memItemLeft" align="right" valign="top"><a id="ae2ecfe26e3713bcda51fb12259041676"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ae2ecfe26e3713bcda51fb12259041676">slidingWindow</a></td></tr>
<tr class="memdesc:ae2ecfe26e3713bcda51fb12259041676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how many operation columns should be generated (2*slidingWindow+1). <br /></td></tr>
<tr class="separator:ae2ecfe26e3713bcda51fb12259041676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe978cbda3fafc57c96c7282a4331c1b"><td class="memItemLeft" align="right" valign="top"><a id="afe978cbda3fafc57c96c7282a4331c1b"></a>
cv::Point2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#afe978cbda3fafc57c96c7282a4331c1b">singleTrajectoryStart</a></td></tr>
<tr class="memdesc:afe978cbda3fafc57c96c7282a4331c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the single trajectory view to the trajectory start. <br /></td></tr>
<tr class="separator:afe978cbda3fafc57c96c7282a4331c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbdfc06a87edc288da1b108842ae9b6"><td class="memItemLeft" align="right" valign="top"><a id="aedbdfc06a87edc288da1b108842ae9b6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aedbdfc06a87edc288da1b108842ae9b6">zoomTop</a></td></tr>
<tr class="memdesc:aedbdfc06a87edc288da1b108842ae9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores zoom information for different views (top view). <br /></td></tr>
<tr class="separator:aedbdfc06a87edc288da1b108842ae9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e094ad35f876150f1e4ea235da35804"><td class="memItemLeft" align="right" valign="top"><a id="a9e094ad35f876150f1e4ea235da35804"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a9e094ad35f876150f1e4ea235da35804">zoomCam</a></td></tr>
<tr class="memdesc:a9e094ad35f876150f1e4ea235da35804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores zoom information for different views (camera view). <br /></td></tr>
<tr class="separator:a9e094ad35f876150f1e4ea235da35804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a03f065b89c95e582bf072d42523731"><td class="memItemLeft" align="right" valign="top"><a id="a8a03f065b89c95e582bf072d42523731"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a8a03f065b89c95e582bf072d42523731">zoomSide</a></td></tr>
<tr class="memdesc:a8a03f065b89c95e582bf072d42523731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores zoom information for different views (side view). <br /></td></tr>
<tr class="separator:a8a03f065b89c95e582bf072d42523731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73d49a327d37bba2bc1e611662d0e90"><td class="memItemLeft" align="right" valign="top"><a id="ad73d49a327d37bba2bc1e611662d0e90"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ad73d49a327d37bba2bc1e611662d0e90">zoomBack</a></td></tr>
<tr class="memdesc:ad73d49a327d37bba2bc1e611662d0e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores zoom information for different views (back view). <br /></td></tr>
<tr class="separator:ad73d49a327d37bba2bc1e611662d0e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dfdf2ed4f641a923289e46a176fce1"><td class="memItemLeft" align="right" valign="top"><a id="a11dfdf2ed4f641a923289e46a176fce1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a11dfdf2ed4f641a923289e46a176fce1">resolution</a></td></tr>
<tr class="memdesc:a11dfdf2ed4f641a923289e46a176fce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores resolution information for different views. <br /></td></tr>
<tr class="separator:a11dfdf2ed4f641a923289e46a176fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6004a8c461bc34d025ec181531060efa"><td class="memItemLeft" align="right" valign="top"><a id="a6004a8c461bc34d025ec181531060efa"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a6004a8c461bc34d025ec181531060efa">singleTrajectoryResolution</a></td></tr>
<tr class="memdesc:a6004a8c461bc34d025ec181531060efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores resolution information for the single trajectory view. <br /></td></tr>
<tr class="separator:a6004a8c461bc34d025ec181531060efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd38352560aebce1e66e3f3fef85caba"><td class="memItemLeft" align="right" valign="top"><a id="acd38352560aebce1e66e3f3fef85caba"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#acd38352560aebce1e66e3f3fef85caba">globalTrajectoryResolution</a></td></tr>
<tr class="memdesc:acd38352560aebce1e66e3f3fef85caba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores resolution information for the global trajectory view. <br /></td></tr>
<tr class="separator:acd38352560aebce1e66e3f3fef85caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab165c49c752a5a3005805f497f68c504"><td class="memItemLeft" align="right" valign="top"><a id="ab165c49c752a5a3005805f497f68c504"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ab165c49c752a5a3005805f497f68c504">singleTrajectoryWidth</a></td></tr>
<tr class="memdesc:ab165c49c752a5a3005805f497f68c504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of the single trajectory view (width). <br /></td></tr>
<tr class="separator:ab165c49c752a5a3005805f497f68c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3812ad8210e3845d279e0979b44161"><td class="memItemLeft" align="right" valign="top"><a id="aad3812ad8210e3845d279e0979b44161"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aad3812ad8210e3845d279e0979b44161">singleTrajectoryHeight</a></td></tr>
<tr class="memdesc:aad3812ad8210e3845d279e0979b44161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of the single trajectory view (height). <br /></td></tr>
<tr class="separator:aad3812ad8210e3845d279e0979b44161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b37ab84b6ca6acdc64559e9ed45aea"><td class="memItemLeft" align="right" valign="top"><a id="a57b37ab84b6ca6acdc64559e9ed45aea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a57b37ab84b6ca6acdc64559e9ed45aea">globalTrajectoryWidth</a></td></tr>
<tr class="memdesc:a57b37ab84b6ca6acdc64559e9ed45aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of the global trajectory view (width). <br /></td></tr>
<tr class="separator:a57b37ab84b6ca6acdc64559e9ed45aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70f78b697a3a411062c9e3e41e31e8c"><td class="memItemLeft" align="right" valign="top"><a id="ab70f78b697a3a411062c9e3e41e31e8c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ab70f78b697a3a411062c9e3e41e31e8c">globalTrajectoryHeight</a></td></tr>
<tr class="memdesc:ab70f78b697a3a411062c9e3e41e31e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of the global trajectory view (height). <br /></td></tr>
<tr class="separator:ab70f78b697a3a411062c9e3e41e31e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ae04c0bf58853a95cebd55dc9563b5"><td class="memItemLeft" align="right" valign="top"><a id="ac8ae04c0bf58853a95cebd55dc9563b5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#ac8ae04c0bf58853a95cebd55dc9563b5">pointSize</a></td></tr>
<tr class="memdesc:ac8ae04c0bf58853a95cebd55dc9563b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores point size information. <br /></td></tr>
<tr class="separator:ac8ae04c0bf58853a95cebd55dc9563b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af282ddb159a0c7764821ebcc71e2b1b6"><td class="memItemLeft" align="right" valign="top"><a id="af282ddb159a0c7764821ebcc71e2b1b6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af282ddb159a0c7764821ebcc71e2b1b6">pointCloudFrequenz</a></td></tr>
<tr class="memdesc:af282ddb159a0c7764821ebcc71e2b1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the point cloud frequency. <br /></td></tr>
<tr class="separator:af282ddb159a0c7764821ebcc71e2b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23832f82888c7a9bed40ceb97139efa4"><td class="memItemLeft" align="right" valign="top"><a id="a23832f82888c7a9bed40ceb97139efa4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a23832f82888c7a9bed40ceb97139efa4">addingFlag</a></td></tr>
<tr class="memdesc:a23832f82888c7a9bed40ceb97139efa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate if objects are being added. <br /></td></tr>
<tr class="separator:a23832f82888c7a9bed40ceb97139efa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff142ade45cca7ac7ae001bf9b43c2a1"><td class="memItemLeft" align="right" valign="top"><a id="aff142ade45cca7ac7ae001bf9b43c2a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aff142ade45cca7ac7ae001bf9b43c2a1">removeBackground</a></td></tr>
<tr class="memdesc:aff142ade45cca7ac7ae001bf9b43c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate if the background should be removed. <br /></td></tr>
<tr class="separator:aff142ade45cca7ac7ae001bf9b43c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1209a9995acebcd29813d625b5bb18"><td class="memItemLeft" align="right" valign="top"><a id="acf1209a9995acebcd29813d625b5bb18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#acf1209a9995acebcd29813d625b5bb18">flagColorObj</a></td></tr>
<tr class="memdesc:acf1209a9995acebcd29813d625b5bb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate if objects should be colored. <br /></td></tr>
<tr class="separator:acf1209a9995acebcd29813d625b5bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8437828bb76ebf2586ac43d72508b71"><td class="memItemLeft" align="right" valign="top"><a id="af8437828bb76ebf2586ac43d72508b71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#af8437828bb76ebf2586ac43d72508b71">flagShowModel</a></td></tr>
<tr class="memdesc:af8437828bb76ebf2586ac43d72508b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate if the model should be shown. <br /></td></tr>
<tr class="separator:af8437828bb76ebf2586ac43d72508b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff27747ceccf2f5fbcf65f24858e12b"><td class="memItemLeft" align="right" valign="top"><a id="afff27747ceccf2f5fbcf65f24858e12b"></a>
std::unordered_map&lt; int, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#afff27747ceccf2f5fbcf65f24858e12b">background</a></td></tr>
<tr class="memdesc:afff27747ceccf2f5fbcf65f24858e12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores background information. <br /></td></tr>
<tr class="separator:afff27747ceccf2f5fbcf65f24858e12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b424bae7a289985245b7397362d2d30"><td class="memItemLeft" align="right" valign="top"><a id="a8b424bae7a289985245b7397362d2d30"></a>
std::unordered_map&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#a8b424bae7a289985245b7397362d2d30">backgroundAngleNormalizer</a></td></tr>
<tr class="memdesc:a8b424bae7a289985245b7397362d2d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores background meta information. <br /></td></tr>
<tr class="separator:a8b424bae7a289985245b7397362d2d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeead0702f63f09972b5ffed96f4fb651"><td class="memItemLeft" align="right" valign="top"><a id="aeead0702f63f09972b5ffed96f4fb651"></a>
std::unordered_map&lt; int, cv::Rect2d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classikg_1_1_labeling.html#aeead0702f63f09972b5ffed96f4fb651">camViewObjCenter</a></td></tr>
<tr class="memdesc:aeead0702f63f09972b5ffed96f4fb651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the center of objects in the camera view. <br /></td></tr>
<tr class="separator:aeead0702f63f09972b5ffed96f4fb651"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classikg_1_1_labeling.html" title="The Labeling class provides functionalities for labeling and processing point cloud data.">Labeling</a> class provides functionalities for labeling and processing point cloud data. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af4c1f078a0ae5e5c9f995e3eb4468165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c1f078a0ae5e5c9f995e3eb4468165">&#9670;&nbsp;</a></span>add_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::add_obj </td>
          <td>(</td>
          <td class="paramtype">cv::Point3d&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new 1m x 1m x 1m bounding box at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position to add the bounding box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f22ce87af6f799efea1ec116b99e1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f22ce87af6f799efea1ec116b99e1c9">&#9670;&nbsp;</a></span>aggregate_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::aggregate_points </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>tId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>eIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>stepSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregate all points within the object bounding box for a single track starting at startIndex up to endIndex by incrementing point cloud index with stepSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tId</td><td>ID of the track. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sIndex</td><td>Start index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eIndex</td><td>End index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>Resolution for aggregation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepSize</td><td>Step size for aggregation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed1758ad29a739c7773f67c2a8af951c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1758ad29a739c7773f67c2a8af951c">&#9670;&nbsp;</a></span>creat_time_heat_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::creat_time_heat_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>heat_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a heat map for the times of the given points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointCloud</td><td>Vector of points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">heat_map</td><td>Generated heat map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bfa8fb74ae8343f533fe3fbe97dc7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfa8fb74ae8343f533fe3fbe97dc7bc">&#9670;&nbsp;</a></span>definalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::definalized </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset the finalize flag at each pose for the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf75e9dca038a8521b6fd776b9c3ae35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf75e9dca038a8521b6fd776b9c3ae35">&#9670;&nbsp;</a></span>erase_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ikg::Labeling::erase_obj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the object with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the object was successfully erased, false otherwise. </dd></dl>

</div>
</div>
<a id="af5dd4b0d551e4bf1edda0be377d7a276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dd4b0d551e4bf1edda0be377d7a276">&#9670;&nbsp;</a></span>erase_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ikg::Labeling::erase_pose </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endTime</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase poses of an object between startTime and endTime. If startTime is smaller than endTime, only the pose at startTime is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTime</td><td>Start time to delete poses from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endTime</td><td>End time to delete poses up to (default is -1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the poses were successfully erased, false otherwise. </dd></dl>

</div>
</div>
<a id="a677e33d70e25dc0bdb0bcf538fe90e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677e33d70e25dc0bdb0bcf538fe90e7f">&#9670;&nbsp;</a></span>extrapolate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::extrapolate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>standingFlag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolate a track for the object with the given objectId up to time toTime. The speed is calculated from the last two or first two poses, or the speed is set to zero if the standingFlag is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toTime</td><td>Time up to which to extrapolate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">standingFlag</td><td>Flag to indicate if the object is standing (default is false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fc4cff6a299b72ac84c88e0f5370a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc4cff6a299b72ac84c88e0f5370a4a">&#9670;&nbsp;</a></span>finalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::finalized </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the finalize flag at each pose for the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431a02c38c377323fe31af936c9b57b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431a02c38c377323fe31af936c9b57b6">&#9670;&nbsp;</a></span>generate_back_view</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_back_view </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a back view of an object by transforming 3D points to the yz-plane of the object coordinate system. Points that occlude the object are removed by a bounding box filter. All points are colored according to their timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated back view image. </dd></dl>

</div>
</div>
<a id="a95d75383c20cb6d7f7444f267653829d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d75383c20cb6d7f7444f267653829d">&#9670;&nbsp;</a></span>generate_camera_global_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_camera_global_view </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>camId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render objects and their masks at a point cloud index to the corresponding camera frame. Masks are generated for each object if its model exists by calculating its convex hull. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time for generating the view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">camId</td><td>ID of the camera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated camera global view image. </dd></dl>

</div>
</div>
<a id="a71f89d3bee501c89664ca950405b42ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f89d3bee501c89664ca950405b42ec">&#9670;&nbsp;</a></span>generate_camera_view</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_camera_view </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>camId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a camera view of an object by transforming a 3D bounding box into a camera image and cropping the image around this box. 3D points within the bounding box are also drawn into the camera image as green circles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">camId</td><td>ID of the camera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated camera view image. </dd></dl>

</div>
</div>
<a id="a09723c9f6dc998ab8195bee6ce458201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09723c9f6dc998ab8195bee6ce458201">&#9670;&nbsp;</a></span>generate_global_point_cloud_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_global_point_cloud_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the global point cloud view: visualizing the actual point cloud and all bounding boxes at this point cloud index. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated global point cloud view image. </dd></dl>

</div>
</div>
<a id="a12754d195294dec9a5cf2d6cdc9416d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12754d195294dec9a5cf2d6cdc9416d5">&#9670;&nbsp;</a></span>generate_side_view</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_side_view </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a side view of an object by transforming 3D points to the xz-plane of the object coordinate system. Points that occlude the object are removed by a bounding box filter. All points are colored according to their timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated side view image. </dd></dl>

</div>
</div>
<a id="a07b93c6d4fb52dc4e7c1a2167896b556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b93c6d4fb52dc4e7c1a2167896b556">&#9670;&nbsp;</a></span>generate_single_trajectory_view</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_single_trajectory_view </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a bird's eye view of a trajectory, drawing positions as circles and headings with arrows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated single trajectory view image. </dd></dl>

</div>
</div>
<a id="a10758294d413df4990b40bece90ab5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10758294d413df4990b40bece90ab5ed">&#9670;&nbsp;</a></span>generate_top_view</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ikg::Labeling::generate_top_view </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a top view of an object by transforming 3D points to the xy-plane of the object coordinate system. Points that occlude the object are removed by a bounding box filter. All points are colored according to their timestamp, and bounding boxes from other objects are also drawn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated top view image. </dd></dl>

</div>
</div>
<a id="af44e534d2cc112c783d3236bb1f0a49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44e534d2cc112c783d3236bb1f0a49b">&#9670;&nbsp;</a></span>get_active_bb_at_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ikg::Labeling::get_active_bb_at_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointCloudIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classikg_1_1_pose.html">Pose</a> *&amp;&#160;</td>
          <td class="paramname"><em>pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the pose of the active object at the specified point cloud index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointCloudIndex</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pose</td><td>Pointer to the pose of the active object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pose was successfully retrieved, false otherwise. </dd></dl>

</div>
</div>
<a id="a4acd8a4ccfb0a8e7ff5403cfc8092186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acd8a4ccfb0a8e7ff5403cfc8092186">&#9670;&nbsp;</a></span>get_cloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PointCloud&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; * ikg::Labeling::get_cloud </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recolor</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a point cloud at the specified index. If not yet loaded, load the point cloud from disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recolor</td><td>Flag to indicate if the point cloud should be recolored (default is false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the point cloud. </dd></dl>

</div>
</div>
<a id="aff2222555fc778ef44f60c88da2b592d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2222555fc778ef44f60c88da2b592d">&#9670;&nbsp;</a></span>get_convex_hull_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; ikg::Labeling::get_convex_hull_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the indices of all points at the convex hull for the given <a class="el" href="struct_i_k_g_b.html" title="Struct representing a point with various attributes.">IKGB</a> point vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Vector of <a class="el" href="struct_i_k_g_b.html" title="Struct representing a point with various attributes.">IKGB</a> points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices of points at the convex hull. </dd></dl>

</div>
</div>
<a id="a8a50cfcee3a094c12c0347f469406eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a50cfcee3a094c12c0347f469406eb1">&#9670;&nbsp;</a></span>get_intersecting_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; ikg::Labeling::get_intersecting_obj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all IDs of objects whose bounding boxes intersect with the specified object ID at a given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time for checking intersections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of intersecting object IDs. </dd></dl>

</div>
</div>
<a id="a3206a7accc991955874fb53805e55a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3206a7accc991955874fb53805e55a30">&#9670;&nbsp;</a></span>get_obj_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, double &gt; ikg::Labeling::get_obj_at </td>
          <td>(</td>
          <td class="paramtype">cv::Point2d&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>activeObjOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the nearest object pose to a given 2D point. The selection can be constrained by time and/or the active object ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>2D point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTime</td><td>Start time for selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endTime</td><td>End time for selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">activeObjOnly</td><td>Flag to indicate if only the active object should be considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of object ID and time. </dd></dl>

</div>
</div>
<a id="a20008513d81c0d3bac52eae32429f4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20008513d81c0d3bac52eae32429f4ca">&#9670;&nbsp;</a></span>get_obj_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, double &gt; ikg::Labeling::get_obj_at </td>
          <td>(</td>
          <td class="paramtype">cv::Point3d&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the object from the objects at the specified point cloud index that is closest to the given 3D point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>3D point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of object ID and distance. </dd></dl>

</div>
</div>
<a id="a10ece5fb59fb9f64c8ec549966a91c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ece5fb59fb9f64c8ec549966a91c92">&#9670;&nbsp;</a></span>get_points_at_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; ikg::Labeling::get_points_at_obj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all points within an object's bounding box. Returns an empty vector if the object doesn't exist at the specified point cloud index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points within the object's bounding box. </dd></dl>

</div>
</div>
<a id="a7eed8752e72f95f0d5a3b452f1fca54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eed8752e72f95f0d5a3b452f1fca54c">&#9670;&nbsp;</a></span>get_time_of_largest_point_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ikg::Labeling::get_time_of_largest_point_segment </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mean timestamp of the largest point segment. Segment by sorting the times and splitting segments with a time difference above the threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Vector of times. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>Time difference threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mean timestamp of the largest point segment. </dd></dl>

</div>
</div>
<a id="ad658e6b9040b57d65452f40d169c1ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad658e6b9040b57d65452f40d169c1ca5">&#9670;&nbsp;</a></span>grid_to_point_cloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::grid_to_point_cloud </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; int, std::unordered_map&lt; int, std::unordered_map&lt; int, int &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a 3D grid [x,y,z,count] to a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>3D grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>Resolution for transformation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>Generated point cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fd157f9be45c7daa1a6ff1ad183d830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd157f9be45c7daa1a6ff1ad183d830">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::init </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dataPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>trajectoryPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>expId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the labeling session by loading the sensor calibration data from the meta file, setting the data path, and loading objects from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataPath</td><td>Path to the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trajectoryPath</td><td>Path to the trajectory data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expId</td><td>Experiment ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54068f42f354a4450e028a8ea85e3e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54068f42f354a4450e028a8ea85e3e66">&#9670;&nbsp;</a></span>interpolate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::interpolate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startTime</em> = <code>-DBL_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endTime</em> = <code>DBL_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the object's pose between the startTime and endTime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTime</td><td>Start time for interpolation (default is -DBL_MAX). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endTime</td><td>End time for interpolation (default is DBL_MAX). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9ed9402464c03bac8d97b9dd156b41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ed9402464c03bac8d97b9dd156b41c">&#9670;&nbsp;</a></span>interpolate_single_between_key_frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::interpolate_single_between_key_frames </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates between key frames (defined by actual step size) around a time stamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time in seconds to interpolate based on the previous and next key frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67767dc75f36d79a56b2df9441eda7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67767dc75f36d79a56b2df9441eda7ea">&#9670;&nbsp;</a></span>load_point_cloud_sliding_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::load_point_cloud_sliding_window </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load point clouds from i-slidingWindow*actualStepSize to i+slidingWindow*actualStepSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Point cloud index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55ba0451612d9a0552f36b13d225e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ba0451612d9a0552f36b13d225e65b">&#9670;&nbsp;</a></span>load_trajectories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::load_trajectories </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load object tracks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the trajectory data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a161987368529ad8401d4ff9107067f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161987368529ad8401d4ff9107067f17">&#9670;&nbsp;</a></span>merge_track</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ikg::Labeling::merge_track </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge track id2 into track id1 by adding the poses of id2 which are later than the last pose or earlier than the first pose of id1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id1</td><td>ID of the first track. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id2</td><td>ID of the second track, which will be deleted if the merging is successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the merge was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ac3d42b10cd07532f0e4bd791a928b64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d42b10cd07532f0e4bd791a928b64d">&#9670;&nbsp;</a></span>point_cloud_to_XYZRGBA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::point_cloud_to_XYZRGBA </td>
          <td>(</td>
          <td class="paramtype">const pcl::PointCloud&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBA &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmpC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform an <a class="el" href="struct_i_k_g_b.html" title="Struct representing a point with various attributes.">IKGB</a> point cloud to a pcl::XYZRGBA cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td><a class="el" href="struct_i_k_g_b.html" title="Struct representing a point with various attributes.">IKGB</a> point cloud. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tmpC</td><td>Generated XYZRGBA cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0022eb4543648769ff4425de22a5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0022eb4543648769ff4425de22a5e2">&#9670;&nbsp;</a></span>point_vector_to_xyz_cloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::point_vector_to_xyz_cloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloudXYZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a point vector to a xyz cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Vector of points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cloudXYZ</td><td>Generated xyz cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ef0fd02bf2b4f81644d76100872b7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef0fd02bf2b4f81644d76100872b7f9">&#9670;&nbsp;</a></span>set_back_ground_color_local_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::set_back_ground_color_local_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classikg_1_1_pose.html">Pose</a> *&#160;</td>
          <td class="paramname"><em>po</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the background color of bird's eye, side, and back view, depending on the pose state. Default color is white, finalized color is blue, interpolated color is gray, and standing color is black. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">po</td><td>Pointer to the pose. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tv</td><td>Image to set the background color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34d9e59049668ad0b60c228245b8804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34d9e59049668ad0b60c228245b8804">&#9670;&nbsp;</a></span>set_point_cloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::set_point_cloud </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the point cloud in the map at view to the point cloud with the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">view</td><td>Position in the map rendered in the corresponding view. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03b4a57183f66120cc790ec99c42f644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b4a57183f66120cc790ec99c42f644">&#9670;&nbsp;</a></span>set_standing_pose_by_key_frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::set_standing_pose_by_key_frames </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all poses between the previous and next key frame to the pose of the previous key frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objId</td><td>ID of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf486823ce1b046b9cb28a3115cf065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf486823ce1b046b9cb28a3115cf065">&#9670;&nbsp;</a></span>split_point_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; ikg::Labeling::split_point_segment </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_i_k_g_b.html">IKGB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the biggest subset of points with homogeneous timestamps with a time difference smaller than the threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Vector of points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Time difference threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points in the largest homogeneous subset. </dd></dl>

</div>
</div>
<a id="a24eb52a72c48888bb02eb851df30c0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24eb52a72c48888bb02eb851df30c0e3">&#9670;&nbsp;</a></span>split_track</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ikg::Labeling::split_track </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitOption&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a track into two simultaneously existing objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id1</td><td>ID of the track to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Width factor for splitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Split option to determine the splitting mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the split was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a474d4b5b1708a48338dcb73cf552ac2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474d4b5b1708a48338dcb73cf552ac2f">&#9670;&nbsp;</a></span>split_track_at_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ikg::Labeling::split_track_at_time </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a track at the given time into two successively occurring tracks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time at which to split the track. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the split was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a2868767de2c920d229990249bfe9ab32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2868767de2c920d229990249bfe9ab32">&#9670;&nbsp;</a></span>update_pc_bb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ikg::Labeling::update_pc_bb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render all bounding boxes at the specified point cloud index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Point cloud index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/model/<a class="el" href="_labeling_8h_source.html">Labeling.h</a></li>
<li>src/model/Labeling.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
